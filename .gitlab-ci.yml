stages:
  - lint
  - security
  - test
  - build
  - package
  - release
  - sync

# Global error handling
.retry_template: &retry_template
  retry:
    max: 2
    when:
      - runner_system_failure
      - stuck_or_timeout_failure
      - api_failure

# Global artifact configuration templates
.artifact_template: &artifact_template
  artifacts:
    expire_in: 1 week
    when: always

.short_artifact_template: &short_artifact_template
  artifacts:
    expire_in: 3 days
    when: always

.long_artifact_template: &long_artifact_template
  artifacts:
    expire_in: 1 month
    when: always

variables:
  GOFLAGS: "-count=1"
  CARGO_TARGET_DIR: "target"
  RUST_BACKTRACE: "1"
  # Resource optimization
  GOGC: "100"
  GOMAXPROCS: "2"
  # Build optimization
  CGO_ENABLED: "1"

# Cache dependencies for faster builds
cache:
  key: 
    files:
      - omni/go.mod
      - omni/native/clift/Cargo.toml
  paths:
    - .go/pkg/mod/
    - target/
    - omni/target/
    - omni/native/clift/target/
  policy: pull-push

# Format and lint checks
fmt:
  stage: lint
  image: 192.168.68.15:5050/pod32g/docker-mirror/golang:1.23
  script:
    - cd omni
    - make fmt
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == "main"

lint:
  stage: lint
  image: 192.168.68.15:5050/pod32g/docker-mirror/golang:1.23
  script:
    - cd omni
    - make lint
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == "main"

# Rust linting
rust-lint:
  stage: lint
  image: 192.168.68.15:5050/pod32g/docker-mirror/rust:1.70
  script:
    - cd omni/native/clift
    - cargo fmt --check
    - cargo clippy -- -D warnings
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == "main"

# Security scanning (basic checks)
security-scan:
  stage: lint
  image: 192.168.68.15:5050/pod32g/docker-mirror/golang:1.23
  script:
    - cd omni
    - echo "Running comprehensive security checks..."
    - echo "Checking for known vulnerabilities in dependencies..."
    - go list -json -deps ./... | grep -i "vulnerability\|security" || echo "No obvious vulnerabilities found in dependency names"
    - echo "Running go mod audit..."
    - go mod audit || echo "go mod audit not available, skipping"
    - echo "Checking for hardcoded secrets..."
    - grep -r -i "password\|secret\|key\|token" --include="*.go" --include="*.yaml" --include="*.yml" . | grep -v ".git" | head -10 || echo "No obvious hardcoded secrets found"
    - echo "Security scan completed"
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == "main"

# Code quality checks (basic)
code-quality:
  stage: lint
  image: 192.168.68.15:5050/pod32g/docker-mirror/golang:1.23
  script:
    - cd omni
    - echo "Running comprehensive code quality checks..."
    - echo "Running go vet..."
    - go vet ./...
    - echo "Checking for unused imports..."
    - go list -f '{{.ImportPath}} {{.Imports}}' ./... | grep -v '\[\]' || echo "No unused imports detected"
    - echo "Running go mod checks..."
    - go mod tidy
    - go mod verify
    - echo "Checking for race conditions..."
    - go test -race -short ./... || echo "Race condition tests completed with issues (expected in some cases)"
    - echo "Code quality checks completed"
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == "main"

# Repository scanning with Trivy for vulnerabilities/misconfigurations/secrets.
trivy-scan:
  stage: security
  image: docker.io/aquasec/trivy:0.55.0
  needs: []
  variables:
    TRIVY_CACHE_DIR: .trivycache
  cache:
    key: "trivy-$CI_COMMIT_REF_SLUG"
    paths:
      - .trivycache
    policy: pull-push
  script:
    - trivy --version
    - |
      set -euo pipefail
      set +e
      trivy fs --scanners vuln,misconfig,secret --severity CRITICAL,HIGH --skip-dirs .git --no-progress --exit-code 1 --format table . | tee trivy-summary.txt
      scan_exit=$?
      set -e
      trivy fs --scanners vuln --severity CRITICAL,HIGH,MEDIUM,LOW --skip-dirs .git --no-progress --exit-code 0 --format sarif --output trivy-report.sarif .
      exit ${scan_exit}
  artifacts:
    paths:
      - trivy-summary.txt
      - trivy-report.sarif
    when: always
    expire_in: 1 week
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == "main"

# Dependency update check (runs weekly)
dependency-check:
  stage: lint
  image: 192.168.68.15:5050/pod32g/docker-mirror/golang:1.23
  script:
    - cd omni
    - echo "Checking for dependency updates..."
    - go list -u -m all | grep -E '\[(minor|patch|major)\]' || echo "No dependency updates available"
    - echo "Checking Go module status..."
    - go mod download
    - go mod verify
    - echo "Dependency check completed"
  rules:
    - if: $CI_PIPELINE_SOURCE == "schedule"
    - if: $CI_COMMIT_BRANCH == "main" && $CI_COMMIT_MESSAGE =~ /.*update.*deps.*/

# Run all tests
test:
  stage: test
  image: 192.168.68.15:5050/pod32g/docker-mirror/golang:1.23
  before_script:
    - apt-get update && apt-get install -y gcc curl
    - curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y
    - source $HOME/.cargo/env
    - rustup default stable
  script:
    - cd omni
    - make clean
    - make build-runtime
    - make build-rust
    - export LD_LIBRARY_PATH=$PWD/native/clift/target/release:$PWD/runtime/posix:$LD_LIBRARY_PATH
    - make test
  coverage: '/coverage: \d+\.\d+%/'
  artifacts:
    paths:
      - omni/coverage/
    expire_in: 2 weeks
    when: always
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == "main"

# Test Rust components
rust-test:
  stage: test
  image: 192.168.68.15:5050/pod32g/docker-mirror/rust:1.70
  script:
    - cd omni/native/clift
    - cargo test --verbose
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == "main"

# Integration testing with real OmniLang programs
integration-test:
  stage: test
  image: 192.168.68.15:5050/pod32g/docker-mirror/golang:1.23
  before_script:
    - apt-get update && apt-get install -y gcc curl
    - curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y
    - source $HOME/.cargo/env
    - rustup default stable
  script:
    - echo "=== INTEGRATION TEST JOB STARTING ==="
    - echo "This should definitely appear in CI log"
    - cd omni
    - echo "Cleaning build artifacts first"
    - make clean
    - echo "Building runtime library first"
    - make build-runtime
    - echo "Building Rust components"
    - make build-rust
    - echo "Building Go binaries"
    - make build
    - export LD_LIBRARY_PATH=$PWD/native/clift/target/release:$PWD/runtime/posix:$LD_LIBRARY_PATH
    - echo "Testing basic compilation"
    - echo 'func main():int { return 42 }' > test_basic.omni
    - ./bin/omnic -backend c -emit exe test_basic.omni -o test_basic
    - ./test_basic || true
    - echo "Basic compilation test completed"
    - echo "Testing std import functionality"
    - echo -e "import std\nfunc main():int {\n    std.io.println(\"Hello from std!\")\n    return 42\n}" > test_std.omni
    - ./bin/omnic -backend c -emit exe test_std.omni -o test_std
    - ./test_std || true
    - echo "Std import test completed"
    - echo "Testing optimization compilation"
    - ./bin/omnic -backend c -O O2 -emit exe test_basic.omni -o test_basic_opt
    - ./test_basic_opt || true
    - echo "Optimization compilation test completed"
    - echo "Testing assembly generation"
    - ./bin/omnic -backend c -emit asm test_basic.omni -o test_basic.s
    - test -f test_basic.s
    - echo "Assembly generation test completed"
    - echo "Testing debug compilation"
    - ./bin/omnic -backend c -debug -emit exe test_basic.omni -o test_basic_debug
    - ./test_basic_debug || true
    - echo "Debug compilation test completed"
    - rm -f test_basic* test_std* test_basic.s
    - rm -rf test_examples
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == "main"

# Comprehensive test suite (runs in parallel with other test jobs)
comprehensive-test:
  stage: test
  image: 192.168.68.15:5050/pod32g/docker-mirror/golang:1.23
  before_script:
    - apt-get update && apt-get install -y gcc curl
    - curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y
    - source $HOME/.cargo/env
    - rustup default stable
  script:
    - cd omni
    - make clean
    - make build-runtime
    - make build-rust
    - make build
    - export LD_LIBRARY_PATH=$PWD/native/clift/target/release:$PWD/runtime/posix:$LD_LIBRARY_PATH
    - echo "Running comprehensive test suite..."
    - echo "Testing all backends..."
    - echo 'func main():int { return 42 }' > test_comprehensive.omni
    - echo "Testing VM backend..."
    - ./bin/omnic -backend vm test_comprehensive.omni || true
    - echo "Testing C backend (default)..."
    - ./bin/omnic -o test_c test_comprehensive.omni
    - echo "Checking what files were created..."
    - ls -la test_* || echo "No test files found"
    - test -f test_c && ./test_c || true
    - test -f test_comprehensive && ./test_comprehensive || true
    - test ! -f test_c && test ! -f test_comprehensive && echo "No C backend executable found, skipping execution"
    - echo "Testing optimization levels..."
    - ./bin/omnic -o test_opt1 -O O1 test_comprehensive.omni
    - test -f test_opt1 && ./test_opt1 || true
    - test ! -f test_opt1 && echo "test_opt1 not found, checking for alternative names..."
    - test ! -f test_opt1 && ls -la test_*opt* || echo "No optimization files found"
    - ./bin/omnic -o test_opt2 -O O2 test_comprehensive.omni
    - test -f test_opt2 && ./test_opt2 || true
    - test ! -f test_opt2 && echo "test_opt2 not found, checking for alternative names..."
    - test ! -f test_opt2 && ls -la test_*opt* || echo "No optimization files found"
    - echo "Testing debug builds..."
    - ./bin/omnic -o test_debug -debug test_comprehensive.omni
    - test -f test_debug && ./test_debug || true
    - test ! -f test_debug && echo "test_debug not found, checking for alternative names..."
    - test ! -f test_debug && ls -la test_*debug* || echo "No debug files found"
    - echo "Comprehensive test completed"
    - echo "Cleaning up test files..."
    - rm -f test_*.omni test_*.mir test_comprehensive test_c test_opt1 test_opt2 test_debug
    - rm -rf test_*_fix.dSYM test_*.dSYM
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == "main"

# Performance benchmarking
benchmark:
  stage: test
  image: 192.168.68.15:5050/pod32g/docker-mirror/golang:1.23
  timeout: 30m
  before_script:
    - apt-get update && apt-get install -y gcc curl
    - curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y
    - source $HOME/.cargo/env
    - rustup default stable
  script:
    - cd omni
    - make clean
    - make build-rust
    - make build-runtime
    - make build
    - export LD_LIBRARY_PATH=$PWD/native/clift/target/release:$PWD/runtime/posix:$LD_LIBRARY_PATH
    - if [ -d "tests/bench" ]; then make bench; fi
  artifacts:
    paths:
      - omni/bench-results/
    expire_in: 1 month
    when: always
  rules:
    - if: $CI_COMMIT_BRANCH == "main"

# Build VS Code extension assets
build-vscode-extension:
  stage: build
  image: 192.168.68.15:5050/pod32g/docker-mirror/node:20
  needs: []
  before_script:
    - cd vscode/omni
    - npm ci
  script:
    - cd vscode/omni
    - npm run compile
    - npx vsce package --no-dependencies
  artifacts:
    paths:
      - vscode/omni/dist/
      - vscode/omni/*.vsix
    when: always
    expire_in: 1 week
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == "main"

# Build for Linux x86_64
build-linux:
  stage: build
  image: 192.168.68.15:5050/pod32g/docker-mirror/golang:1.23
  timeout: 20m
  <<: *retry_template
  before_script:
    - apt-get update && apt-get install -y gcc curl
    - curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y
    - source $HOME/.cargo/env
    - rustup default stable
  script:
    - cd omni
    - make clean
    - make build-runtime
    - make build-rust
    - make build
    - export LD_LIBRARY_PATH=$PWD/native/clift/target/release:$PWD/runtime/posix:$LD_LIBRARY_PATH
    - make test
  artifacts:
    paths:
      - omni/bin/
      - omni/target/release/
    expire_in: 3 days
    when: always
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == "main"

# Build for macOS (using Linux with cross-compilation)
build-macos:
  stage: build
  image: 192.168.68.15:5050/pod32g/docker-mirror/golang:1.23
  <<: *retry_template
  before_script:
    - apt-get update && apt-get install -y gcc curl
    - curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y
    - source $HOME/.cargo/env
    - rustup default stable
  script:
    - cd omni
    - make build-rust
    - CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 make build
    - CGO_ENABLED=0 GOOS=darwin GOARCH=arm64 make build
  artifacts:
    paths:
      - omni/bin/
    expire_in: 3 days
    when: always
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == "main"

# Build for Windows
build-windows:
  stage: build
  image: 192.168.68.15:5050/pod32g/docker-mirror/golang:1.23
  <<: *retry_template
  before_script:
    - apt-get update && apt-get install -y gcc curl
    - curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y
    - source $HOME/.cargo/env
    - rustup default stable
  script:
    - cd omni
    - make build-rust
    - CGO_ENABLED=0 GOOS=windows GOARCH=amd64 make build
  artifacts:
    paths:
      - omni/bin/
    expire_in: 3 days
    when: always
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == "main"

# Create distribution package
package:
  stage: package
  image: 192.168.68.15:5050/pod32g/docker-mirror/golang:1.23
  dependencies:
    - build-linux
    - build-macos
    - build-windows
  before_script:
    - apt-get update && apt-get install -y zip tar gzip curl
    - curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y
    - source $HOME/.cargo/env
    - rustup default stable
  script:
    - cd omni
    - make build-runtime
    - make build-rust
    - make build
    - export LD_LIBRARY_PATH=$PWD/native/clift/target/release:$PWD/runtime/posix:$LD_LIBRARY_PATH
    - make package
  artifacts:
    paths:
      - omni/dist/
    expire_in: 2 weeks
    when: always
  rules:
    - if: $CI_COMMIT_BRANCH == "main"

# Create release
release:
  stage: release
  image: 192.168.68.15:5050/pod32g/docker-mirror/golang:1.23
  dependencies:
    - package
  script:
    - apt-get update && apt-get install -y jq
    - cd omni
    - make release
    - RELEASE_DIR="releases"
    - MANIFEST="${RELEASE_DIR}/release.json"
    - if [ ! -f "${MANIFEST}" ]; then
        echo "release.json is missing";
        exit 1;
      fi
    - jq -e '.version and (.artifacts | length > 0)' "${MANIFEST}" >/dev/null
    - |
      jq -r '.artifacts[] | "\(.name) \(.sha256)"' "${MANIFEST}" | while IFS=' ' read -r name sha; do
        if [ -z "${name}" ] || [ -z "${sha}" ]; then
          echo "skipping empty manifest row"
          continue
        fi
        artifact_path="${RELEASE_DIR}/${name}"
        if [ ! -f "${artifact_path}" ]; then
          echo "Artifact listed in manifest not found: ${artifact_path}"
          exit 1
        fi
        computed_sha=$(sha256sum "${artifact_path}" | awk '{print $1}')
        if [ "${computed_sha}" != "${sha}" ]; then
          echo "Checksum mismatch for ${name}: manifest=${sha} computed=${computed_sha}"
          exit 1
        fi
      done
    - DOCKER_ARCHIVE=$(ls "${RELEASE_DIR}"/omni-*-docker.tar 2>/dev/null | head -n 1 || true)
    - if [ -z "${DOCKER_ARCHIVE}" ]; then
        echo "Docker archive not found in ${RELEASE_DIR}";
        exit 1;
      fi
    - tar tf "${DOCKER_ARCHIVE}" > /tmp/docker_tar_contents.txt
    - if ! grep -q 'manifest.json' /tmp/docker_tar_contents.txt; then
        echo "Docker archive ${DOCKER_ARCHIVE} does not contain manifest.json";
        exit 1;
      fi
  rules:
    - if: $CI_COMMIT_TAG
  artifacts:
    paths:
      - omni/releases/
    expire_in: 6 months
    when: always

# Mirror the repository to GitHub once other jobs succeed.
sync-to-github:
  stage: sync
  image: 192.168.68.15:5050/pod32g/docker-mirror/alpine:latest
  needs: []
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      when: manual
      allow_failure: false
    - if: '$CI_COMMIT_TAG'
      when: manual
      allow_failure: false
    - when: never
  script:
    - apk add --no-cache git
    - |
      set -euo pipefail
      sync_identity_name="${GITHUB_USERNAME:-${GITLAB_USER_NAME:-GitLab CI}}"
      sync_identity_email="${GITHUB_EMAIL:-${GITLAB_USER_EMAIL:-ci@example.com}}"
      sync_http_user="${GITHUB_USERNAME:-${GITLAB_USER_LOGIN:-gitlab-ci}}"
      if [ -z "${GITHUB_TOKEN:-}" ]; then
        echo "GITHUB_TOKEN variable is required for GitHub mirroring."
        exit 1
      fi
      repo_url="${GITHUB_REPO_URL:-}"
      if [ -z "${repo_url}" ]; then
        if [ -n "${GITHUB_REPO:-}" ]; then
          repo_url="https://github.com/${GITHUB_REPO}.git"
        else
          echo "Set GITHUB_REPO_URL or GITHUB_REPO so the GitHub remote can be derived."
          exit 1
        fi
      fi
      workdir="$(mktemp -d)"
      trap 'rm -rf "${workdir}"' EXIT
      git clone --filter=blob:none "${CI_REPOSITORY_URL}" "${workdir}/repo"
      cd "${workdir}/repo"
      git config user.name "${sync_identity_name}"
      git config user.email "${sync_identity_email}"
      sanitized_repo_url="${repo_url}"
      case "${sanitized_repo_url}" in
        https://*)
          sanitized_repo_url="${sanitized_repo_url#https://}"
          ;;
        http://*)
          sanitized_repo_url="${sanitized_repo_url#http://}"
          ;;
        *)
          echo "Only HTTPS GitHub remotes are supported."
          exit 1
          ;;
      esac
      git remote add github "https://${sync_http_user}:${GITHUB_TOKEN}@${sanitized_repo_url}"
      git fetch origin "${CI_COMMIT_REF_NAME}"
      git checkout --detach "${CI_COMMIT_SHA}"
      rm -f .gitlab-ci.yml
      git update-index --force-remove .gitlab-ci.yml 2>/dev/null || true
      git commit --amend --allow-empty --no-edit --reset-author
      if [ -n "${CI_COMMIT_TAG:-}" ]; then
        git tag -f "${CI_COMMIT_TAG}"
        git push --force github "refs/tags/${CI_COMMIT_TAG}"
      else
        git branch -f "${CI_COMMIT_REF_NAME}"
        git push --force github "HEAD:refs/heads/${CI_COMMIT_REF_NAME}"
      fi
  variables:
    GIT_DEPTH: "0"
